{
	"name"			: "ESP32",
	"port"			: 0,										// 変更禁止
	"boardType"		: "esp32:esp32:esp32",						// package:platform:board

	"sort"			: 50,										// メニュー上の表示順序
	"extensionAuthor": "sohtamei",								// この拡張スクリプトの作者
	"helpURL"		: "http://sohta02.web.fc2.com/familyday_shield.html#LiquidCrystal",
	"productInfoURL": "http://sohta02.web.fc2.com/familyday_shield.html#LiquidCrystal",
	"sampleDir"		: "",										// サンプルディレクトリ
	"javascriptURL"	: "robot.js",
	"normalFW"		: "",										// 最初のプログラム,  .ino, .cpp.standard.hex
	"pcmodeFW"		: "robot_pcmode/robot_pcmode",				// PC modeプログラム, .ino, .cpp.standard.hex, .ino.template
	"prefs"			: ["custom_CPUFreq=esp32_240",
						"custom_DebugLevel=esp32_none",
						"custom_FlashFreq=esp32_80",
						"custom_FlashMode=esp32_qio",
						"custom_FlashSize=esp32_4M",
						"custom_PSRAM=esp32_disabled",
						"custom_PartitionScheme=esp32_default",
						"custom_UploadSpeed=esp32_921600"],

	// C言語記述注意 : " を使うときは \" とすること

	// PCモード/書き込みモード ヘッダ (C言語)
	"header":"
#define mVersion \"ESP32 1.0\"

#include <WiFi.h>
#include <AsyncUDP.h>
#include <Preferences.h>

#define PORT  54321
#define DPRINT(a) // _Serial.println(a) // for debug

char g_ssid[32] = {0};
char g_pass[32] = {0};
WiFiServer server(PORT);
WiFiClient client;
AsyncUDP udp;
Preferences preferences;
char buf[256];

enum {
CONNECTION_NONE = 0,
CONNECTION_CONNECTING,
CONNECTION_WIFI,
CONNECTION_TCP,
};
uint8_t connection_status = CONNECTION_NONE;
uint32_t connection_start = 0;

uint8_t connectWifi(char* ssid, char*pass)
{
  strncpy(g_ssid, ssid, sizeof(g_ssid)-1);
  strncpy(g_pass, pass, sizeof(g_pass)-1);
  preferences.putString(\"ssid\",g_ssid);
  preferences.putString(\"password\",g_pass);
  WiFi.begin(g_ssid, g_pass);
  connection_status = CONNECTION_CONNECTING;
  connection_start = millis();
  return waitWifi();
}

uint8_t waitWifi(void)
{
  for(int i=0;i<80;i++) {
    delay(100);
    if(WiFi.status()==WL_CONNECTED) break;
  }
  return WiFi.status();
}

char* statusWifi(void)
{
  preferences.getString(\"ssid\", g_ssid, sizeof(g_ssid));
  memset(buf, 0, sizeof(buf));

  if(WiFi.status() == WL_CONNECTED) {
    IPAddress ip = WiFi.localIP();
    snprintf(buf,sizeof(buf)-1,\"%d\\t%s\\t%d.%d.%d.%d\", WiFi.status(), g_ssid, ip[0],ip[1],ip[2],ip[3]);
  } else {
    snprintf(buf,sizeof(buf)-1,\"%d\\t%s\", WiFi.status(), g_ssid);
  }
  return buf;
}

char* scanWifi(void)
{
  memset(buf, 0, sizeof(buf));

  int n = WiFi.scanNetworks();
  for(int i = 0; i < n; i++) {
    if(i == 0) {
      snprintf(buf, sizeof(buf)-1, \"%s\", WiFi.SSID(i).c_str());
    } else {
      int ofs = strlen(buf);
      snprintf(buf+ofs, sizeof(buf)-1-ofs, \"\\t%s\", WiFi.SSID(i).c_str());
    }
  }
  return buf;
}

// connect        : DISCONNECTED->(NO_SSID_AVAIL)->IDLE->CONNECTED
// disconnect     : DISCONNECTED->(NO_SSID_AVAIL)->IDLE->CONNECTED->DISCONNECTED
// no SSID        : DISCONNECTED->NO_SSID_AVAIL (timeout)
// password error : DISCONNECTED (timeout)
uint32_t last_udp;
int readWifi(void)
{
  if(WiFi.status() != WL_CONNECTED) {
    switch(connection_status) {
    case CONNECTION_TCP:
    case CONNECTION_WIFI:
      WiFi.disconnect();
      connection_status = CONNECTION_NONE;
      break;
    case CONNECTION_CONNECTING:
      if(millis() - connection_start > 8000) {
        WiFi.disconnect();
        connection_status = CONNECTION_NONE;
      }
      break;
    }
    return -1;
  }

  uint32_t cur = millis();
  if(cur - last_udp > 2000) {
    last_udp = cur;
//  udp.broadcastTo(mVersion, PORT);
    uint32_t adrs = WiFi.localIP();
    uint32_t subnet = WiFi.subnetMask();
    udp.writeTo((uint8_t*)mVersion, sizeof(mVersion)-1, IPAddress(adrs|~subnet), PORT);
  }

  switch(connection_status) {
  case CONNECTION_NONE:
  case CONNECTION_CONNECTING:
    server.begin();
#if defined(_M5STACK_H_) || defined(_M5STICKC_H_)
    M5.Lcd.fillScreen(BLACK);
    M5.Lcd.setCursor(0,0);
    M5.Lcd.println(WiFi.localIP());
#endif
    DPRINT(WiFi.localIP());
    connection_status = CONNECTION_WIFI;

  case CONNECTION_WIFI:
    client = server.available();
    if(!client) {
      return -1;
    }
    DPRINT(\"connected\");
    connection_status = CONNECTION_TCP;

  case CONNECTION_TCP:
    if(!client.connected()) {
      DPRINT(\"disconnected\");
      client.stop();
      connection_status = CONNECTION_WIFI;
      return -1;
    }
    if(client.available()<=0) {
      return -1;
    }
    return client.read();
  }
}
",
	// PCモード/書き込みモード setup処理 (C言語)
	"setup":"
preferences.begin(\"tukurutch\", false);

Serial.begin(115200);

preferences.getString(\"ssid\", g_ssid, sizeof(g_ssid));
preferences.getString(\"password\", g_pass, sizeof(g_pass));
Serial.print(\"Connecting to \");    Serial.println(g_ssid);

//WiFi.mode(WIFI_STA);
if(g_ssid[0]) {
  WiFi.begin(g_ssid, g_pass);
  connection_status = CONNECTION_CONNECTING;
  connection_start = millis();
  #ifndef PCMODE
    waitWifi();
  #endif
}
",
	// PCモード/書き込みモード loop処理 (C言語)
	"loop":"",

	// PCモード/書き込みモード スクラッチブロック定義
	"blockSpecs": [
	// type			: w-実行関数, R-取得関数, B-true/false取得, h-プログラム開始
	// Block定義	: パラメータ %n-数値, %d-数値+enum, %s-文字列, %m-文字列+enum
	// remote		: 通常関数, 引数+戻値 型定義 B-int8, S-int16, L-int32, F-float, D-double, s-string, b-byteArray
	// custom		: 特殊関数, robot.js呼び出し(ext.Block名). PCモードと書き込みモードで処理を分けるとき使用。
	// enum			: enum値取得
	// 実行/取得関数: 引数 {0},{1}, 関数の区切り＝wブロック';', R/Bブロック','  (C言語)

	//  type | Block定義                               | Block名           | 初期値     |remote/custom/enum    | 実行/取得関数
	//-------+-----------------------------------------+-------------------+------------+----------------------+----------------------------------
		["h", "Program Start",							"runArduino",					{}],	// 変更禁止

		["-"],	// ブロック区切り

		["w", "set LED %d.onoff",						"setLED",			"On",		{"remote":["B"],		"func":"pinMode(13,OUTPUT);digitalWrite(13,{0});"}],
		["w", "set digital pin %n output as %d.digital","setDigital",		13,"HIGH",	{"remote":["B","B"],	"func":"pinMode({0},OUTPUT);digitalWrite({0},{1});"}],
//		["w", "set digital pin A%n output as %d.digital","setDigitalA",		0,"HIGH",	{"remote":["B","B"],	"func":"pinMode(A0+{0},OUTPUT);digitalWrite(A0+{0},{1});"}],
		["B", "read digital pin %n",					"getDigital",		9,			{"remote":["B",		"B"],"func":"pinMode({0},INPUT),digitalRead({0})"}],
//		["B", "read digital pin A%n",					"getDigitalA",		0,			{"remote":["B",		"B"],"func":"pinMode(A0+{0},INPUT),digitalRead(A0+{0})"}],
//		["R", "read analog pin A%n",					"getAnalog",		0,			{"remote":["B",		"S"],"func":"pinMode(A0+{0},INPUT),analogRead(A0+{0})"}],

		["-"],

		// WiFi設定
		["R", "status WIFI",							"statusWifi",					{"remote":[			"s"],"func":"statusWifi()"}],
		["R", "scan WIFI",								"scanWifi",						{"remote":[			"s"],"func":"scanWifi()"}],
		["R", "connect WIFI %s %s",						"connectWifi","ssid","pass",	{"remote":["s","s",	"B"],"func":"connectWifi({0},{1})"}],
	],
	"menus": {
		"digital":["HIGH","LOW"],
		"onoff":["On","Off"],
	},
	"values":{
		"HIGH":1,"LOW":0,
		"On":1,"Off":0,
	},
	"translators":{
		"ja":{
			"set LED %d.onoff"								:"LEDを %d.onoff",
			"set digital pin %n output as %d.digital"		:"デジタルピン %n の出力を %d.digital にする",
			"set digital pin A%n output as %d.digital"		:"デジタルピン A%n の出力を %d.digital にする",
			"read digital pin %n"							:"デジタルピン %n",
			"read digital pin A%n"							:"デジタルピン A%n",
			"read analog pin A%n"							:"アナログピン A%n",
		}
	}
}
