// copyright to SohtaMei 2019.

// HEADER

#ifdef __AVR_ATmega328P__
#include <avr/wdt.h>
#endif

#if defined(_SAMD21_)
#define _Serial SerialUSB
#else
#define _Serial Serial
#endif

enum {
RSP_BYTE    = 1,
RSP_SHORT   = 2,
RSP_LONG    = 3,
RSP_FLOAT   = 4,
RSP_DOUBLE  = 5,
RSP_STRING  = 6,
};

#define getBufLen(n) (buffer+4+offsetIdx[n]+1),*(buffer+4+offsetIdx[n]+0)

void setup()
{
#ifdef __AVR_ATmega328P__
MCUSR = 0;
wdt_disable();
#endif
// SETUP
_Serial.println("PC mode: " mVersion);
}

static uint8_t buffer[256];  // 0xFF,0x55,len,cmd,
static uint8_t _packetLen = 4;

#define ARG_NUM  16
#define ITEM_NUM (sizeof(ArgTypesTbl)/sizeof(ArgTypesTbl[0]))
static uint8_t offsetIdx[ARG_NUM] = {0};
static const char ArgTypesTbl[][ARG_NUM] = {
// ARG_TYPES_TBL
};

#if 0		// wifi debug
#define DPRINT(a) _Serial.println(a)
#define DWRITE(a) _Serial.write(a)
#else
#define DPRINT(a)
#define DWRITE(a)
#endif

uint8_t wifi_uart = 0;

void _write(uint8_t byte)
{
#if defined(ESP32)
  if(wifi_uart)
    client.write(byte);
  else
#endif
    _Serial.write(byte);
}

void _println(char* mes)
{
#if defined(ESP32)
  if(wifi_uart)
    client.println(mes);
  else
#endif
    _Serial.println(mes);
}

#if defined(ESP32)
enum {
  CONNECTION_NONE = 0,
  CONNECTION_WIFI,
  CONNECTION_TCP,
};
uint8_t connection_status = CONNECTION_NONE;
uint32_t last_udp;
#endif

int16_t _read(void)
{
  if(_Serial.available()>0) {
    wifi_uart = 0;
    return _Serial.read();
  }

#if defined(ESP32)
  switch(connection_status) {
  case CONNECTION_NONE:
    if(WiFi.status() != WL_CONNECTED) {
      return -1;
    }
    server.begin();
    M5.Lcd.clear(BLACK);
    M5.Lcd.setCursor(0,0);
    M5.Lcd.println(WiFi.localIP());
    DPRINT(WiFi.localIP());
    connection_status = CONNECTION_WIFI;

  case CONNECTION_WIFI:
    client = server.available();
    if(!client) {
      uint32_t cur = millis();
      if(last_udp - cur > 1000) {
        last_udp = cur;
        udp.broadcastTo("m5stack", PORT);
      }
      return -1;
    }
    DPRINT("connected");
    connection_status = CONNECTION_TCP;

  case CONNECTION_TCP:
    if(!client.connected()) {
      DPRINT("disconnected");
      client.stop();
      connection_status = CONNECTION_WIFI;
      return -1;
    }
    if(client.available()<=0) {
      return -1;
    }
    wifi_uart = 1;
    return client.read();
  }
#endif
  return -1;
}

static void parseData()
{
uint8_t i;
memset(offsetIdx, 0, sizeof(offsetIdx));
if(buffer[3] < ITEM_NUM) {
const char *ArgTypes = ArgTypesTbl[buffer[3]];
uint16_t offset = 0;
for(i = 0; i < ARG_NUM && ArgTypes[i]; i++) {
offsetIdx[i] = offset;
switch(ArgTypes[i]) {
case 'B': offset += 1; break;
case 'S': offset += 2; break;
case 'L': offset += 4; break;
case 'F': offset += 4; break;
case 'D': offset += 8; break;
case 's': offset += strlen((char*)buffer+4+offset)+1; break;
case 'b': offset += buffer[4+offset]+1; break;
default: break;
}
if(4+offset > _packetLen) return;
}
}

switch(buffer[3]){
// WORK
case 0xFE:  // firmware name
_println("PC mode: " mVersion);
break;
case 0xFF:  // software reset
#if defined(__AVR_ATmega328P__)
wdt_enable(WDTO_15MS);
while(1);
#elif defined(_SAMD21_)
NVIC_SystemReset();
#elif defined(ESP32)
ESP.restart();
#endif
break;
//### CUSTOMIZED ###
#ifdef REMOTE_ENABLE	// check remoconRoboLib.h or quadCrawlerRemocon.h
#define CMD_CHECKREMOTEKEY  0x80
case CMD_CHECKREMOTEKEY:
sendRemote();
break;
#endif
}
}

static uint8_t _index = 0;
void loop()
{
int16_t c;
while((c=_read()) >= 0) {
DWRITE(c);
buffer[_index++] = c;

switch(_index) {
case 1:
_packetLen = 4;
if(c != 0xff)
_index = 0;
break;
case 2:
if(c != 0x55) 
_index = 0;
break;
case 3:
_packetLen = 3+c;
break;
}
if(_index >= _packetLen) {
parseData();
_index = 0;
}
if(_index >= sizeof(buffer)) {
_index = 0;
}
}
// LOOP
}

union floatConv { 
float _float;
uint8_t _byte[4];
} conv;

union doubleConv {
double _double;
uint8_t _byte[8];
};

uint8_t getByte(uint8_t n)
{
return buffer[4+offsetIdx[n]];
}

int16_t getShort(uint8_t n)
{
uint8_t x = 4+offsetIdx[n];
return buffer[x+0]|((uint32_t)buffer[x+1]<<8);
}
int32_t getLong(uint8_t n)
{
uint8_t x = 4+offsetIdx[n];
return buffer[x+0]|((uint32_t)buffer[x+1]<<8)|((uint32_t)buffer[x+2]<<16)|((uint32_t)buffer[x+3]<<24);
}

float getFloat(uint8_t n)
{
uint8_t x = 4+offsetIdx[n];
union floatConv conv;
for(uint8_t i=0; i<4; i++) {
conv._byte[i] = buffer[x+i];
}
return conv._float;
}

double getDouble(uint8_t n)
{
uint8_t x = 4+offsetIdx[n];
union doubleConv conv;
for(uint8_t i=0; i<8; i++) {
conv._byte[i] = buffer[x+i];
}
return conv._double;
}

char* getString(uint8_t n)
{
uint8_t x = 4+offsetIdx[n];
return (char*)buffer+x;
}

static void callOK()
{
_write(0xff);
_write(0x55);
_write((uint8_t)0);
}

static void sendByte(uint8_t data)
{
_write(0xff);
_write(0x55);
_write(1+sizeof(uint8_t));
_write(RSP_BYTE);
_write(data);
}

static void sendShort(uint16_t data)
{
_write(0xff);
_write(0x55);
_write(1+sizeof(uint16_t));
_write(RSP_SHORT);
_write(data&0xff);
_write(data>>8);
}

static void sendLong(uint32_t data)
{
_write(0xff);
_write(0x55);
_write(1+sizeof(uint32_t));
_write(RSP_LONG);
_write(data&0xff);
_write(data>>8);
_write(data>>16);
_write(data>>24);
}

static void sendFloat(float data)
{
union floatConv conv;
conv._float = data;

_write(0xff);
_write(0x55);
_write(1+sizeof(float));
_write(RSP_FLOAT);
_write(conv._byte[0]);
_write(conv._byte[1]);
_write(conv._byte[2]);
_write(conv._byte[3]);
}

static void sendDouble(double data)
{
union doubleConv conv;
conv._double = data;

_write(0xff);
_write(0x55);
_write(1+sizeof(double));
_write(RSP_DOUBLE);
for(uint8_t i=0; i<8; i++) {
_write(conv._byte[i]);
}
}

static void sendString(String s)
{
uint8_t l = s.length();

_write(0xff);
_write(0x55);
_write(1+l);
_write(RSP_STRING);
for(uint8_t i=0; i<l; i++) {
_write(s.charAt(i));
}
}

//### CUSTOMIZED ###
#ifdef REMOTE_ENABLE	// check remoconRoboLib.h or quadCrawlerRemocon.h
static void sendRemote(void)
{
uint16_t data;
_write(0xff);
_write(0x55);
_write(1+1+2+2);
_write(CMD_CHECKREMOTEKEY);
_write(remote.checkRemoteKey());
data = remote.x;
_write(data&0xff);
_write(data>>8);
data = remote.y;
_write(data&0xff);
_write(data>>8);
}
#endif
