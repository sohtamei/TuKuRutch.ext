{
	"name"			: "duke32.udpoff",
	"port"			: 0,										// 変更禁止
	"boardType"		: "esp32:esp32:esp32",						// package:platform:board

	"sort"			: 50,										// メニュー上の表示順序
	"extensionAuthor": "Thousandiy",							// この拡張スクリプトの作者
	"helpURL"		: "http://sohta02.web.fc2.com/familyday_shield.html",
	"productInfoURL": "https://thousandiy.wordpress.com/",
	"sampleDir"		: "sample/duke32",							// サンプルディレクトリ
	"javascriptURL"	: "robot.js",
	"normalFW"		: "robot_normal/robot_normal",				// 最初のプログラム,  .ino, .cpp.standard.hex
	"pcmodeFW"		: "robot_pcmode/robot_pcmode",				// PC modeプログラム, .ino, .cpp.standard.hex, .ino.template
	"prefs"			: ["custom_CPUFreq=esp32_240",
						"custom_DebugLevel=esp32_none",
						"custom_FlashFreq=esp32_80",
						"custom_FlashMode=esp32_qio",
						"custom_FlashSize=esp32_4M",
						"custom_PSRAM=esp32_disabled",
						"custom_PartitionScheme=esp32_default",
						"custom_UploadSpeed=esp32_921600"],

	// C言語記述注意 : " を使うときは \" とすること

	// PCモード/書き込みモード ヘッダ (C言語)
	"header":"
#define mVersion \"duke32 1.0\"

#include <WiFi.h>
#include <AsyncUDP.h>
#include <Preferences.h>

#include <Wire.h>

#define PORT  54321

char g_ssid[32] = {0};
char g_pass[32] = {0};
WiFiServer server(PORT);
WiFiClient client;
AsyncUDP udp;
Preferences preferences;
char buf[256];

// duke32.h
/********************************
* for LED Control
*********************************/
#define NEO_PIN     27

/********************************
* for Servo Control
*********************************/
#define Servo_PIN1  23
#define Servo_PIN2   4

#define LEDC_CHANNEL_0  0  // channel of 16 channels (started from zero)
#define LEDC_CHANNEL_1  1  // channel of 16 channels (started from zero)
#define LEDC_TIMER_BIT 12  // use 12 bit precission for LEDC timer
#define LEDC_BASE_FREQ 50  // use 50 Hz as a LEDC base frequency

// Servo Range
// int srvMin = 103; // (103/4096)*20ms = 0.5 ms (-90c)
// int srvMax = 491; // (491/4096)*20ms = 2.4 ms (+90c)
#define srvMin 103
#define srvMax 491

/********************************
* for Motor Control
*********************************/
#define MTR_A1  13  // moterA IN1
#define MTR_A2  12  // moterA IN2
#define MTR_AE  18  // moterA EN
#define MTR_B1  14  // moterB IN1
#define MTR_B2  15  // moterB IN2
#define MTR_BE  19  // moterB EN

#define LEDC_CHANNEL_2  2   // channel of 16 channels (started from zero)
#define LEDC_CHANNEL_3  3   // channel of 16 channels (started from zero)
#define LEDC_TIMER_BIT_MTR 8    // use 8 bit precission for LEDC timer
#define LEDC_BASE_FREQ_MTR 255  // use 50 Hz as a LEDC base frequency

#define MotorL 2
#define MotorR 3

/********************************
* for I/O Control
*********************************/
#define ANA11   34
#define ANA12   35
#define A34     34  //I, GPIO34, ADC1_CH6
#define A35     35  //I, GPIO35, ADC1_CH7

#define DIGI01  32
#define DIGI02  33
#define D32     32  //IO, GPIO32, ADC1_CH4, TOUCH9
#define D33     33  //IO, GPIO33, ADC1_CH5, TOUCH8

#define DIGI11  26
#define DIGI12  25
#define D26     26  //IO, GPIO25, DAC_1, ADC2_CH8
#define D25     25  //IO, GPIO26, DAC_2, ADC2_CH9

// I2C
#define I2CSDA  21
#define I2CSCL  22
#define D21     21  //IO, GPIO21
#define D22     22  //IO, GPIO22

// UART2
#define UARTRXD 16
#define UARTTXD 17
#define D16     16  //IO, GPIO16, U2RXD
#define D17     17  //IO, GPIO17, U2TXD
// --- duke32.h


// robot_normal.ino
#define useLED
/********************************
* for LED Control
*********************************/
#ifdef useLED
  // https://github.com/Makuna/NeoPixelBus
  #include <NeoPixelBus.h>
  
  const uint16_t PixelCount = 64;

  // three element pixels, in different order and speeds
  //NeoPixelBus<NeoRgbFeature, Neo400KbpsMethod> strip(PixelCount, NEO_PIN);
  NeoPixelBus<NeoGrbFeature, Neo800KbpsMethod> ledStrip(PixelCount, NEO_PIN);

  String ledValueR = String(0);
  String ledValueG = String(0);
  String ledValueB = String(0);

  uint8_t colorR = ledValueR.toInt() / 2;
  uint8_t colorG = ledValueG.toInt() / 2;
  uint8_t colorB = ledValueB.toInt() / 2;
#endif

/********************************
* for Servo Control
*********************************/
String servoValueL = String(90);
String servoValueR = String(90);

uint8_t servoNo;    // Set 0 or 1
uint16_t angle;     // min=0, max=180
uint16_t servoL = servoValueL.toInt();
uint16_t servoR = servoValueR.toInt();


/********************************
* for Motor Control
*********************************/
const uint8_t motorInterval = 30;  //[ms]
// --- robot_normal.ino


// duke32.cpp
/********************************
* for Servo Control
*********************************/
void servoInit(){
  // Setup timer and attach timer to a servo pin
  ledcSetup(LEDC_CHANNEL_0, LEDC_BASE_FREQ, LEDC_TIMER_BIT);
  ledcAttachPin(Servo_PIN1, LEDC_CHANNEL_0);

  ledcSetup(LEDC_CHANNEL_1, LEDC_BASE_FREQ, LEDC_TIMER_BIT);
  ledcAttachPin(Servo_PIN2, LEDC_CHANNEL_1);
}

void setServo(uint8_t servoNo, uint16_t angle){
  uint16_t pwmWidth;

  if(servoNo < 0){
    servoNo = 0;
  }else if(servoNo > 1){
    servoNo = 1;
  }

  if(angle < 0){
    angle = 0;
  }else if(angle > 180){
    angle = 180;
  }

  pwmWidth = ((srvMax - srvMin) / 180) * angle + srvMin;

  ledcWrite(servoNo, pwmWidth);
}

/********************************
* for Motor Control
*********************************/
void Motor_INIT(){
  pinMode(MTR_A1, OUTPUT);
  pinMode(MTR_A2, OUTPUT);
//  pinMode(MTR_AE, OUTPUT);
  pinMode(MTR_B1, OUTPUT);
  pinMode(MTR_B2, OUTPUT);
//  pinMode(MTR_BE, OUTPUT);

  digitalWrite(MTR_A1, LOW);
  digitalWrite(MTR_A2, LOW);
//  digitalWrite(MTR_AE, LOW);
  digitalWrite(MTR_B1, LOW);
  digitalWrite(MTR_B2, LOW);
//  digitalWrite(MTR_BE, LOW);

  // Setup timer and attach timer to a servo pin
  ledcSetup(LEDC_CHANNEL_2, LEDC_BASE_FREQ_MTR, LEDC_TIMER_BIT_MTR);
  ledcAttachPin(MTR_AE, LEDC_CHANNEL_2);

  ledcSetup(LEDC_CHANNEL_3, LEDC_BASE_FREQ_MTR, LEDC_TIMER_BIT_MTR);
  ledcAttachPin(MTR_BE, LEDC_CHANNEL_3);
}

void setMotorSpeed(uint8_t motorNo, uint8_t speed){
  if(motorNo < 2){
    motorNo = 2;
  }else if(motorNo > 3){
    motorNo = 3;
  }

  if(speed < 0){
    speed = 0;
  }else if(speed > 255){
    speed = 255;
  }

  ledcWrite(motorNo, speed);
}

void motorL_forward(uint8_t speed){
//  digitalWrite(MTR_AE, HIGH);
  setMotorSpeed(MotorL, speed);
  digitalWrite(MTR_A1, HIGH);
  digitalWrite(MTR_A2, LOW);
}

void motorL_back(uint8_t speed){
//  digitalWrite(MTR_AE, HIGH);
  setMotorSpeed(MotorL, speed);
  digitalWrite(MTR_A1, LOW);
  digitalWrite(MTR_A2, HIGH);
}

void motorL_stop(){
//  digitalWrite(MTR_AE, LOW);
  setMotorSpeed(MotorL, 0);
  digitalWrite(MTR_A1, LOW);
  digitalWrite(MTR_A2, LOW);
}

void motorR_forward(uint8_t speed){
//  digitalWrite(MTR_BE, HIGH);
  setMotorSpeed(MotorR, speed);
  digitalWrite(MTR_B1, HIGH);
  digitalWrite(MTR_B2, LOW);
}
void motorR_back(uint8_t speed){
//  digitalWrite(MTR_BE, HIGH);
  setMotorSpeed(MotorR, speed);
  digitalWrite(MTR_B1, LOW);
  digitalWrite(MTR_B2, HIGH);
}

void motorR_stop(){
//  digitalWrite(MTR_BE, LOW);
  setMotorSpeed(MotorR, 0);
  digitalWrite(MTR_B1, LOW);
  digitalWrite(MTR_B2, LOW);
}
// --- duke32.cpp

void setMotor(uint8_t index, uint8_t dir)
{
  if(index == 0) {
    switch(dir) {
    case 0: motorL_stop();       break;
    case 1: motorL_forward(255); break;
    case 2: motorL_back(255);    break;
    }
  } else if(index == 1) {
    switch(dir) {
    case 0: motorR_stop();       break;
    case 1: motorR_forward(255); break;
    case 2: motorR_back(255);    break;
    }
  }
}

struct {
  int  L;
  int  R;
} static const dir_table[7] = {
 //L  R
  {0, 0},  // STOP
  {1, 1},  // FORWARD
  {0, 1},  // LEFT
  {1, 0},  // RIGHT
  {2, 2},  // BACK
  {2, 1},  // ROLL_LEFT
  {1, 2},  // ROLL_RIGHT
};

void setRobot(int direction)
{
  setMotor(0, dir_table[direction].L);
  setMotor(1, dir_table[direction].R);
}

/*
 * ADC
 */
void ADC_INIT(){
  pinMode(ANA11, INPUT);
  pinMode(ANA12, INPUT);
}

uint16_t getAdc(uint8_t index)
{
uint8_t adcCh[2] = {ANA11,ANA12};
if(index>=2) return 0;
return analogRead(adcCh[index]);
}

/*
 * DIO in
 */
void DIO_INIT(){
  pinMode(DIGI01, INPUT);
  pinMode(DIGI02, INPUT);
  pinMode(DIGI11, INPUT);
  pinMode(DIGI12, INPUT);
}

uint8_t getDigital(uint8_t index)
{
uint8_t din_ch[4] = {DIGI01,DIGI02,DIGI11,DIGI12};
if(index>=4) return 0;
return digitalRead(din_ch[index]);
}

#ifdef useLED
/********************************
* for LED Control
*********************************/
#define colorSaturation 32
RgbColor red(colorSaturation, 0, 0);
RgbColor green(0, colorSaturation, 0);
RgbColor blue(0, 0, colorSaturation);
RgbColor white(colorSaturation);
RgbColor black(0);

void SetNeoPixel(uint8_t index){
RgbColor* npcolor = NULL;
switch(index) {
  case 0: npcolor = &black; break;
  case 1: npcolor = &red;   break;
  case 2: npcolor = &green; break;
  case 3: npcolor = &blue;  break;
  case 4: npcolor = &white; break;
  default: return;
}

for(uint8_t i=0; i<PixelCount; i++){
ledStrip.SetPixelColor(i, *npcolor);
}
ledStrip.Show();
}
#endif

uint8_t connectWifi(char* ssid, char*pass)
{
  strncpy(g_ssid, ssid, sizeof(g_ssid)-1);
  strncpy(g_pass, pass, sizeof(g_pass)-1);
  preferences.putString(\"ssid\",g_ssid);
  preferences.putString(\"password\",g_pass);
  WiFi.begin(g_ssid, g_pass);
  return waitWifi();
}

uint8_t waitWifi(void)
{
  for(int i=0;i<80;i++) {
    delay(100);
    if(WiFi.status()==WL_CONNECTED) break;
  }
  return WiFi.status();
}

char* statusWifi(void)
{
preferences.getString(\"ssid\", g_ssid, sizeof(g_ssid));
memset(buf, 0, sizeof(buf));

if(WiFi.status() == WL_CONNECTED) {
  IPAddress ip = WiFi.localIP();
  snprintf(buf,sizeof(buf)-1,\"%d\\t%s\\t%d.%d.%d.%d\", WiFi.status(), g_ssid, ip[0],ip[1],ip[2],ip[3]);
} else {
  snprintf(buf,sizeof(buf)-1,\"%d\\t%s\", WiFi.status(), g_ssid);
}
return buf;
}

char* scanWifi(void)
{
memset(buf, 0, sizeof(buf));

int n = WiFi.scanNetworks();
for(int i = 0; i < n; i++) {
  if(i == 0) {
    snprintf(buf, sizeof(buf)-1, \"%s\", WiFi.SSID(i).c_str());
  } else {
    int ofs = strlen(buf);
    snprintf(buf+ofs, sizeof(buf)-1-ofs, \"\\t%s\", WiFi.SSID(i).c_str());
  }
}
return buf;
}
",
	// PCモード/書き込みモード setup処理 (C言語)
	"setup":"
preferences.begin(\"tukurutch\", false);

// robot_normal.ino
Serial.begin(115200);

#ifdef useLED
  ledStrip.Begin();
#endif

// reset all Servo to initial Position
servoInit();
setServo(0, servoL);
setServo(1, servoR);

// reset all Motor to initial Setting
Motor_INIT();
delay(50);
setMotorSpeed(MotorL, 0);
setMotorSpeed(MotorR, 0);

// init ADC
ADC_INIT();

// init DIO
DIO_INIT();


preferences.getString(\"ssid\", g_ssid, sizeof(g_ssid));
preferences.getString(\"password\", g_pass, sizeof(g_pass));
Serial.print(\"Connecting to \");    Serial.println(g_ssid);

//WiFi.mode(WIFI_STA);
if(g_ssid[0]) {
  WiFi.begin(g_ssid, g_pass);
  #ifndef PCMODE
    waitWifi();
  #endif
}
",
	// PCモード/書き込みモード loop処理 (C言語)
	"loop":"",

	// PCモード/書き込みモード スクラッチブロック定義
	"blockSpecs": [
	// type			: w-実行関数, R-取得関数, B-true/false取得, h-プログラム開始
	// Block定義	: パラメータ %n-数値, %d-数値+enum, %s-文字列, %m-文字列+enum
	// remote		: 通常関数, 引数+戻値 型定義 B-int8, S-int16, L-int32, F-float, D-double, s-string, b-byteArray
	// custom		: 特殊関数, robot.js呼び出し(ext.Block名). PCモードと書き込みモードで処理を分けるとき使用。
	// enum			: enum値取得
	// 実行/取得関数: 引数 {0},{1}, 関数の区切り＝wブロック';', R/Bブロック','  (C言語)

	//  type | Block定義                               | Block名           | 初期値     |remote/custom/enum    | 実行/取得関数
	//-------+-----------------------------------------+-------------------+------------+----------------------+----------------------------------
		["h", "Program Start",							"runArduino",					{}],	// 変更禁止

		["-"],	// ブロック区切り

		["w", "%d.direction .",							"setRobot",		  "run forward",{"remote":["B"],		"func":"setRobot({0});"}],
		["w", "stop",									"stopRobot",					{"remote":[],			"func":"setRobot(0);"}],
		["w", "set motor%d.servoch direction%d.motordir","setMotor",	"ch-L","forward",{"remote":["B","B"],	"func":"setMotor({0},{1});"}],
		["R", "%d.direction .",							"enumDirection",  "run forward",{"enum":"",				"func":"{0}"}],

		["-"],

		["w", "NeoPixel %d.neopixel",					"setNeoPixel",		"white",	{"remote":["B"],		"func":"SetNeoPixel({0});"}],
		["w", "set servo %m.servoch %n",				"setServo",			"ch-L",90,	{"remote":["B","B"],	"func":"setServo({0},{1});"}],
		["B", "read digital pin %d.din",				"getDigital",		0,			{"remote":["B",		"B"],"func":"getDigital({0})"}],
		["R", "read analog pin %d.analog",				"getAnalog",		0,			{"remote":["B",		"S"],"func":"getAdc({0})"}],

		["-"],

		["R", "connect WIFI %s %s",						"connectWifi","ssid","pass",	{"remote":["s","s",	"B"],"func":"connectWifi({0},{1})"}],
		["R", "status WIFI",							"statusWifi",					{"remote":[			"s"],"func":"statusWifi()"}],
		["R", "scan WIFI",								"scanWifi",						{"remote":[			"s"],"func":"scanWifi()"}],
	],
	"menus": {
		"neopixel":["black","red","green","blue","white"],
		"motordir":["stop","forward","back"],
		"direction":["stop","run forward","turn left","turn right","run backward","rotate left","rotate right"],
		"din":[0,1,2,3],
		"analog":[0,1],
		"servoch":["ch-L","ch-R"],

		"digital":["HIGH","LOW"],
		"onoff":["On","Off"],
	},
	"values":{
		"black":0,"red":1,"green":2,"blue":3,"white":4,
		"stop":0,"forward":1,"back":2,
		"run forward":1,"turn left":2,"turn right":3,"run backward":4,"rotate left":5,"rotate right":6,
		"ch-L":0,"ch-R":1,

		"HIGH":1,"LOW":0,
		"On":1,"Off":0,
	},
	"translators":{
		"ja":{
			"run forward":"前", "turn left":"左", "turn right":"右", "run backward":"後", "rotate left":"左旋回", "rotate right":"右旋回",
			"read digital pin %d.din"						:"デジタルピン %d.din",
			"read analog pin %d.analog"						:"アナログピン %d.analog",
		}
	}
}
