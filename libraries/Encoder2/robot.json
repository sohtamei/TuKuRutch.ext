{
	"name"			: "Encoder2",
	"port"			: 0,										// 変更禁止
	"boardType"		: "esp32:esp32:m5stack-core-esp32",			// package:platform:board

	"sort"			: 10,										// メニュー上の表示順序
	"extensionAuthor": "sohtamei",								// この拡張スクリプトの作者
	"helpURL"		: "",
	"productInfoURL": "",
	"sampleDir"		: "",										// サンプルディレクトリ
	"javascriptURL"	: "robot.js",
	"normalFW"		: "",										// 最初のプログラム,  .ino, .cpp.standard.hex (option)
	"pcmodeFW"		: "robot_pcmode/robot_pcmode",				// PC modeプログラム, .ino, .cpp.standard.hex, .ino.template
	"prefs"			: ["custom_CPUFreq=esp32_240",
						"custom_DebugLevel=m5stack-core-esp32_none",
						"custom_FlashFreq=esp32_80",
						"custom_FlashMode=esp32_qio",
						"custom_FlashSize=esp32_4M",
						"custom_PSRAM=esp32_disabled",
						"custom_PartitionScheme=m5stack-core-esp32_default",
						"custom_UploadSpeed=m5stack-core-esp32_115200"],


	// C言語記述注意 : " を使うときは \" とすること

	// PCモード/書き込みモード ヘッダ (C言語)
	"header":"
#define mVersion \"Encoder1.0\"

#include <M5Atom.h>
#include \"TukurutchEsp.h\"

WebsocketsServer wsServer;
#define numof(a) (sizeof(a)/sizeof((a)[0]))

uint32_t last_enc[2] = {0,0};
int32_t duration[2] = {0,0};
uint8_t cnt[2] = {0,0};
#define CNT_MAX		10
#define P_ENC0A		22
#define P_ENC0B		19
#define P_ENC1A		23
#define P_ENC1B		33
#define P_LED		21
#define P_SRV0		32
#define P_SRV1		26

uint8_t ledStatus = 0;
static void irq_int0(void)
{
  cnt[0]++;
  if(cnt[0] >= CNT_MAX) {
    cnt[0] = 0;

    uint32_t cur = micros();
    uint32_t d = (cur - last_enc[0]) & ~0x80000000;
    duration[0] = digitalRead(P_ENC0B) ? d: -d;
    last_enc[0] = cur;

    ledStatus ^= 1;
    digitalWrite(P_LED, ledStatus);
  }
  attachInterrupt(digitalPinToInterrupt(P_ENC0A), irq_int0, FALLING);  // RISING
}

static void irq_int1(void)
{
  cnt[1]++;
  if(cnt[1] >= CNT_MAX) {
    cnt[1] = 0;

    uint32_t cur = micros();
    uint32_t d = (cur - last_enc[1]) & ~0x80000000;
    duration[1] = digitalRead(P_ENC1B) ? d: -d;
    last_enc[1] = cur;
  }
  attachInterrupt(digitalPinToInterrupt(P_ENC1A), irq_int1, FALLING);  // RISING
}

static int16_t _getSpeed(uint8_t index)
{
  int32_t ret = duration[index];
  if(!ret) return 0;
  duration[index] = 0;
  return (1000000000L/(50L/CNT_MAX))/ret;  // us -> m rps
//  return ret;
}

const struct {uint8_t ledc; uint8_t port;} servoTable[] = {{8,P_SRV0},{9,P_SRV1}};
void _setServo(uint8_t idx, int16_t data/*normal:0~180, continuous:-100~+100*/, uint8_t continuous)
{
  if(idx >= numof(servoTable)) return;

  uint16_t pwmWidth;
#if 1
  pwmWidth = data;
#else
  if(continuous) {
    #define srvZero 307		// 1.5ms/20ms*4096 = 307.2
    #define srvCoef 163		// (2.3ms-1.5ms)/20ms*4096 = 163.8
    if(data < -100) data = -100;
    else if(data > 100) data = 100;
    if(idx == 1) data = -data;
    pwmWidth = (data * srvCoef) / 100 + srvZero;
    if(data==0 && continuous!=2) pwmWidth=0;
  } else {
    #define srvMin 103		// 0.5ms/20ms*4096 = 102.4 (-90c)
    #define srvMax 491		// 2.4ms/20ms*4096 = 491.5 (+90c)
    if(data < 0) data = 0;
    else if(data > 180) data = 180;
    pwmWidth = (data * (srvMax - srvMin)) / 180 + srvMin;
  }
#endif
  ledcAttachPin(servoTable[idx].port, servoTable[idx].ledc);
  ledcWrite(servoTable[idx].ledc, pwmWidth);
}

void _stopServo(void)
{
  _setServo(0,0,1);
  _setServo(1,0,1);
}
",
	// PCモード/書き込みモード setup処理 (C言語)
	"setup":"
pinMode(P_LED, OUTPUT);
digitalWrite(P_LED, ledStatus);

Serial.begin(115200);

pinMode(P_ENC0A, INPUT);
pinMode(P_ENC0B, INPUT);
attachInterrupt(digitalPinToInterrupt(P_ENC0A), irq_int0, FALLING);
pinMode(P_ENC1A, INPUT);
pinMode(P_ENC1B, INPUT);
attachInterrupt(digitalPinToInterrupt(P_ENC1A), irq_int1, FALLING);

// ServoCar
ledcSetup(servoTable[0].ledc, 50/*Hz*/, 12/*bit*/);
ledcSetup(servoTable[1].ledc, 50/*Hz*/, 12/*bit*/);
",
	// PCモード/書き込みモード loop処理 (C言語)
	"loop":"",

	// PCモード/書き込みモード スクラッチブロック定義
	"blockSpecs": [
	// type			: w-実行関数, R-取得関数, B-true/false取得, h-プログラム開始
	// Block定義	: パラメータ %n-数値, %d-数値+enum, %s-文字列, %m-文字列+enum
	// remote		: 通常関数, 引数+戻値 型定義 B-int8, S-int16, L-int32, F-float, D-double, s-string, b-byteArray
	// custom		: 特殊関数, robot.js呼び出し(ext.Block名). PCモードと書き込みモードで処理を分けるとき使用。
	// enum			: enum値取得
	// 実行/取得関数: 引数 {0},{1}, 関数の区切り＝wブロック';', R/Bブロック','  (C言語)

	//  type | Block定義                               | Block名           | 初期値     |remote/custom/enum    | 実行/取得関数
	//-------+-----------------------------------------+-------------------+------------+----------------------+----------------------------------
		["h", "Program Start",							"runArduino",					{}],	// 変更禁止

		["w", "set LED %d.servoch",						"setLED",			1,			{"remote":["B"],		"func":"pinMode(P_LED,OUTPUT);digitalWrite(P_LED,{0});"}],
		["R", "get speed %n",							"getSpeed",			0,			{"remote":["B",		"S"],"func":"_getSpeed({0})"}],
		["w", "set motor %d.servoch speed %d.speed",	"setMotor",			0,0,		{"remote":["B","S"],	"func":"_setServo({0},{1},1);"}],
		["w", "stop",									"stopCar",						{"remote":[],			"func":"_stopServo();"}],

//		["B", "remote pressed",							"checkRemoteKey",				{"custom":"", 			"func":"remote.checkRemoteKey()"}],

	],
	"menus": {
		"servoch"	:[0,1],
	//	"speed"		:[100,50,0,-50,-100],
		"speed"		:[471,307,143,0],
	},
	"values":{
	},
	"translators":{
		"ja":{
		}
	}
}
