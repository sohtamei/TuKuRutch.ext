{
	"name"			: "Duke32AIO",
	"port"			: 0,										// 変更禁止
	"boardType"		: "esp32:esp32:esp32",						// package:platform:board

	"sort"			: 50,										// メニュー上の表示順序
	"extensionAuthor": "Thousandiy",							// この拡張スクリプトの作者
	"helpURL"		: "http://sohta02.web.fc2.com/familyday_shield.html",
	"productInfoURL": "https://thousandiy.wordpress.com/",
	"sampleDir"		: "sample/Duke32AIO",						// サンプルディレクトリ
	"javascriptURL"	: "robot.js",
	"normalFW"		: "robot_normal/robot_normal",				// 最初のプログラム,  .ino, .cpp.standard.hex
	"pcmodeFW"		: "robot_pcmode/robot_pcmode",				// PC modeプログラム, .ino, .cpp.standard.hex, .ino.template
	"prefs"			: ["custom_CPUFreq=esp32_240",
						"custom_DebugLevel=esp32_none",
						"custom_FlashFreq=esp32_80",
						"custom_FlashMode=esp32_qio",
						"custom_FlashSize=esp32_4M",
						"custom_PSRAM=esp32_disabled",
						"custom_PartitionScheme=esp32_default",
						"custom_UploadSpeed=esp32_921600"],

	// C言語記述注意 : " を使うときは \" とすること

	// PCモード/書き込みモード ヘッダ (C言語)
	"header":"
#define mVersion \"Duke32AIO 1.0\"

#include <WiFi.h>
#include <WiFiUdp.h>
#include <AsyncUDP.h>
#include <Preferences.h>

#include <Wire.h>

#define PORT  54321
#define REMOTE_PORT 10000
#define DPRINT(a) // _Serial.println(a) // for debug

char g_ssid[32] = {0};
char g_pass[32] = {0};
WiFiServer server(PORT);
WiFiClient client;
WiFiUDP remoteUdp;
AsyncUDP udp;
Preferences preferences;
char buf[256];

// duke32.h
/********************************
* for LED Control
*********************************/
#define NEO_PIN     27

/********************************
* for Servo Control
*********************************/
#define Servo_PIN1  23
#define Servo_PIN2   4

#define LEDC_CHANNEL_0  0  // channel of 16 channels (started from zero)
#define LEDC_CHANNEL_1  1  // channel of 16 channels (started from zero)
#define LEDC_TIMER_BIT 12  // use 12 bit precission for LEDC timer
#define LEDC_BASE_FREQ 50  // use 50 Hz as a LEDC base frequency

// Servo Range
// int srvMin = 103; // (103/4096)*20ms = 0.5 ms (-90c)
// int srvMax = 491; // (491/4096)*20ms = 2.4 ms (+90c)
#define srvMin 103
#define srvMax 491

/********************************
* for Motor Control
*********************************/
#define MTR_A1  13  // moterA IN1
#define MTR_A2  12  // moterA IN2
#define MTR_AE  18  // moterA EN
#define MTR_B1  14  // moterB IN1
#define MTR_B2  15  // moterB IN2
#define MTR_BE  19  // moterB EN

#define LEDC_CHANNEL_2  2   // channel of 16 channels (started from zero)
#define LEDC_CHANNEL_3  3   // channel of 16 channels (started from zero)
#define LEDC_TIMER_BIT_MTR 8    // use 8 bit precission for LEDC timer
#define LEDC_BASE_FREQ_MTR 255  // use 50 Hz as a LEDC base frequency

#define MotorL 0
#define MotorR 1

/********************************
* for I/O Control
*********************************/
#define ANA11   34
#define ANA12   35
#define A34     34  //I, GPIO34, ADC1_CH6
#define A35     35  //I, GPIO35, ADC1_CH7

#define DIGI01  32
#define DIGI02  33
#define D32     32  //IO, GPIO32, ADC1_CH4, TOUCH9
#define D33     33  //IO, GPIO33, ADC1_CH5, TOUCH8

#define DIGI11  26
#define DIGI12  25
#define D26     26  //IO, GPIO25, DAC_1, ADC2_CH8
#define D25     25  //IO, GPIO26, DAC_2, ADC2_CH9

// I2C
#define I2CSDA  21
#define I2CSCL  22
#define D21     21  //IO, GPIO21
#define D22     22  //IO, GPIO22

// UART2
#define UARTRXD 16
#define UARTTXD 17
#define D16     16  //IO, GPIO16, U2RXD
#define D17     17  //IO, GPIO17, U2TXD
// --- duke32.h


// robot_normal.ino
#define useLED
/********************************
* for LED Control
*********************************/
#ifdef useLED
  // https://github.com/Makuna/NeoPixelBus
  #include <NeoPixelBus.h>
  
  const uint16_t PixelCount = 64;

  // three element pixels, in different order and speeds
  //NeoPixelBus<NeoRgbFeature, Neo400KbpsMethod> strip(PixelCount, NEO_PIN);
  NeoPixelBus<NeoGrbFeature, Neo800KbpsMethod> ledStrip(PixelCount, NEO_PIN);

  String ledValueR = String(0);
  String ledValueG = String(0);
  String ledValueB = String(0);

  uint8_t colorR = ledValueR.toInt() / 2;
  uint8_t colorG = ledValueG.toInt() / 2;
  uint8_t colorB = ledValueB.toInt() / 2;
#endif

/********************************
* for Servo Control
*********************************/
String servoValueL = String(90);
String servoValueR = String(90);

uint8_t servoNo;    // Set 0 or 1
uint16_t angle;     // min=0, max=180
uint16_t servoL = servoValueL.toInt();
uint16_t servoR = servoValueR.toInt();


/********************************
* for Motor Control
*********************************/
const uint8_t motorInterval = 30;  //[ms]
// --- robot_normal.ino


/********************************
* for RCWController
*********************************/

// UDP byte offset
enum {
  PACKET_BUTTON_H = 0,
  PACKET_BUTTON_L,
  PACKET_LEFT_X,
  PACKET_LEFT_Y,
  PACKET_RIGHT_X,
  PACKET_RIGHT_Y,
  PACKET_ACCEL_X,
  PACKET_ACCEL_Y,
  PACKET_ACCEL_Z,
  PACKET_CONFIG,

  PACKET_SIZE,
};

// key code
enum {
  BUTTON_UP = 1,
  BUTTON_DOWN,
  BUTTON_RIGHT,
  BUTTON_LEFT,
  BUTTON_Y,
  BUTTON_A,
  BUTTON_B,
  BUTTON_X,
  BUTTON_L1,
  BUTTON_L2,
  BUTTON_R1,
  BUTTON_R2,
  BUTTON_START,		// 0x3
  BUTTON_SELECT,	// 0xc
};

// bitN -> key code変換
const uint8_t keyTable2[] = {
  BUTTON_UP,
  BUTTON_DOWN,
  BUTTON_RIGHT,
  BUTTON_LEFT,
  BUTTON_Y,
  BUTTON_A,
  BUTTON_B,
  0,

  BUTTON_X,
  BUTTON_L1,
  BUTTON_L2,
  BUTTON_R1,
  BUTTON_R2,
};

// config
union config {
  uint8_t byte;
  struct {
    uint8_t  rotate  :3;   // (1)portrait,(2)landscapeL,(3)landscapeR,(4)reverse
    uint8_t  left    :1;   // (1)analog
    uint8_t  right   :1;   // (1)analog
    uint8_t  accel   :2;   // (0)off,(1)on,(2)left,(3)right
  } b;
};

class WifiRemote {
public:
  int16_t  x;
  int16_t  y;
  uint8_t  keys;  // BUTTON_xx

  WifiRemote() {
    initialized = false;
    keys = 0;
  }
  int checkRemoteKey(void) {
    if(!initialized) {
      remoteUdp.begin(REMOTE_PORT);
      initialized = true;
    }
    return keys;
  }
  int isRemoteKey(uint8_t key) {
    return (keys==key);
  }
  void updateRemote(void) {
    if(!initialized) return;
    int rlen = remoteUdp.parsePacket();
    if(rlen>=PACKET_SIZE) {
      uint8_t buf[16];
      if(rlen >= sizeof(buf)) rlen = sizeof(buf);
      remoteUdp.read(buf, rlen);
      int d = buf[PACKET_BUTTON_L]|(buf[PACKET_BUTTON_H]<<8);
      keys = 0;
      for(int i=0; i<sizeof(keyTable2); i++) {
        if(d & (1<<i)) {
          keys = keyTable2[i];
          break;
        }
      }
      x = buf[PACKET_LEFT_X]-0x80;
      y = buf[PACKET_LEFT_Y]-0x80;
    //  snprintf((char*)buf,sizeof(buf),\"%d,%d,%d\",keys,x,y);
    //  Serial.println((char*)buf);
    }
  }
private:
  uint8_t initialized;
} remote;

#define REMOTE_ENABLE	// for robot_pcmode.ino.template


// duke32.cpp
/********************************
* for Servo Control
*********************************/
void servoInit(){
  // Setup timer and attach timer to a servo pin
  ledcSetup(LEDC_CHANNEL_0, LEDC_BASE_FREQ, LEDC_TIMER_BIT);
  ledcAttachPin(Servo_PIN1, LEDC_CHANNEL_0);

  ledcSetup(LEDC_CHANNEL_1, LEDC_BASE_FREQ, LEDC_TIMER_BIT);
  ledcAttachPin(Servo_PIN2, LEDC_CHANNEL_1);
}

void setServo(uint8_t servoNo, uint16_t angle){
  uint16_t pwmWidth;

  if(servoNo < 0){
    servoNo = 0;
  }else if(servoNo > 1){
    servoNo = 1;
  }

  if(angle < 0){
    angle = 0;
  }else if(angle > 180){
    angle = 180;
  }

  pwmWidth = ((srvMax - srvMin) / 180) * angle + srvMin;

  ledcWrite(servoNo, pwmWidth);
}

/********************************
* for Motor Control
*********************************/
void Motor_INIT(){
  pinMode(MTR_A1, OUTPUT);
  pinMode(MTR_A2, OUTPUT);
//  pinMode(MTR_AE, OUTPUT);
  pinMode(MTR_B1, OUTPUT);
  pinMode(MTR_B2, OUTPUT);
//  pinMode(MTR_BE, OUTPUT);

  digitalWrite(MTR_A1, LOW);
  digitalWrite(MTR_A2, LOW);
//  digitalWrite(MTR_AE, LOW);
  digitalWrite(MTR_B1, LOW);
  digitalWrite(MTR_B2, LOW);
//  digitalWrite(MTR_BE, LOW);

  // Setup timer and attach timer to a servo pin
  ledcSetup(LEDC_CHANNEL_2, LEDC_BASE_FREQ_MTR, LEDC_TIMER_BIT_MTR);
  ledcAttachPin(MTR_AE, LEDC_CHANNEL_2);

  ledcSetup(LEDC_CHANNEL_3, LEDC_BASE_FREQ_MTR, LEDC_TIMER_BIT_MTR);
  ledcAttachPin(MTR_BE, LEDC_CHANNEL_3);
}
// --- duke32.cpp

void setMotorSpeed(uint8_t motorNo, int16_t speed){
  if(motorNo >= 2) return;

  int16_t abs = speed;
  if(abs < 0)   abs = -abs;
  if(abs > 255) abs = 255;
  ledcWrite(motorNo+LEDC_CHANNEL_2, abs);

  switch(motorNo) {
  case MotorL:
    digitalWrite(MTR_A1, (speed>0) ? HIGH:LOW);
    digitalWrite(MTR_A2, (speed<0) ? HIGH:LOW);
    break;
  case MotorR:
    digitalWrite(MTR_B1, (speed>0) ? HIGH:LOW);
    digitalWrite(MTR_B2, (speed<0) ? HIGH:LOW);
    break;
  }
}

struct { int16_t L; int16_t R;
} static const dir_table[7] = {
//  L   R
  { 0,  0},  // STOP
  { 1,  1},  // FORWARD
  { 0,  1},  // LEFT
  { 1,  0},  // RIGHT
  {-1, -1},  // BACK
  {-1,  1},  // ROLL_LEFT
  { 1, -1},  // ROLL_RIGHT
};

void setRobot(uint8_t direction, uint8_t speed)
{
  setMotorSpeed(MotorL, speed * dir_table[direction].L);
  setMotorSpeed(MotorR, speed * dir_table[direction].R);
}

/*
 * ADC
 */
void ADC_INIT(){
  pinMode(ANA11, INPUT);
  pinMode(ANA12, INPUT);
}

uint16_t getAdc(uint8_t index)
{
  uint8_t adcCh[2] = {ANA11,ANA12};
  if(index>=2) return 0;
  return analogRead(adcCh[index]);
}

/*
 * DIO in
 */
void DIO_INIT(){
  pinMode(DIGI01, INPUT);
  pinMode(DIGI02, INPUT);
  pinMode(DIGI11, INPUT);
  pinMode(DIGI12, INPUT);
}

uint8_t getDigital(uint8_t index)
{
  uint8_t din_ch[4] = {DIGI01,DIGI02,DIGI11,DIGI12};
  if(index>=4) return 0;
  return digitalRead(din_ch[index]);
}

#ifdef useLED
/********************************
* for LED Control
*********************************/
#define colorSaturation 32
RgbColor red(colorSaturation, 0, 0);
RgbColor green(0, colorSaturation, 0);
RgbColor blue(0, 0, colorSaturation);
RgbColor white(colorSaturation);
RgbColor black(0);

void SetNeoPixel(uint8_t index){
  RgbColor* npcolor = NULL;
  switch(index) {
    case 0: npcolor = &black; break;
    case 1: npcolor = &red;   break;
    case 2: npcolor = &green; break;
    case 3: npcolor = &blue;  break;
    case 4: npcolor = &white; break;
    default: return;
  }

  for(uint8_t i=0; i<PixelCount; i++){
    ledStrip.SetPixelColor(i, *npcolor);
  }
  ledStrip.Show();
}

void SetNeoPixelRGB(uint8_t r, uint8_t g, uint8_t b){
  if(r>32) r=32;
  if(g>32) g=32;
  if(b>32) b=32;
  RgbColor color(r,g,b);

  for(uint8_t i=0; i<PixelCount; i++){
    ledStrip.SetPixelColor(i, color);
  }
  ledStrip.Show();
}
#endif

enum {
CONNECTION_NONE = 0,
CONNECTION_CONNECTING,
CONNECTION_WIFI,
CONNECTION_TCP,
};
uint8_t connection_status = CONNECTION_NONE;
uint32_t connection_start = 0;

uint8_t connectWifi(char* ssid, char*pass)
{
  strncpy(g_ssid, ssid, sizeof(g_ssid)-1);
  strncpy(g_pass, pass, sizeof(g_pass)-1);
  preferences.putString(\"ssid\",g_ssid);
  preferences.putString(\"password\",g_pass);
  WiFi.begin(g_ssid, g_pass);
  connection_status = CONNECTION_CONNECTING;
  connection_start = millis();
  return waitWifi();
}

uint8_t waitWifi(void)
{
  for(int i=0;i<80;i++) {
    delay(100);
    if(WiFi.status()==WL_CONNECTED) break;
  }
  return WiFi.status();
}

char* statusWifi(void)
{
  preferences.getString(\"ssid\", g_ssid, sizeof(g_ssid));
  memset(buf, 0, sizeof(buf));

  if(WiFi.status() == WL_CONNECTED) {
    IPAddress ip = WiFi.localIP();
    snprintf(buf,sizeof(buf)-1,\"%d\\t%s\\t%d.%d.%d.%d\", WiFi.status(), g_ssid, ip[0],ip[1],ip[2],ip[3]);
  } else {
    snprintf(buf,sizeof(buf)-1,\"%d\\t%s\", WiFi.status(), g_ssid);
  }
  return buf;
}

char* scanWifi(void)
{
  memset(buf, 0, sizeof(buf));

  int n = WiFi.scanNetworks();
  for(int i = 0; i < n; i++) {
    if(i == 0) {
      snprintf(buf, sizeof(buf)-1, \"%s\", WiFi.SSID(i).c_str());
    } else {
      int ofs = strlen(buf);
      snprintf(buf+ofs, sizeof(buf)-1-ofs, \"\\t%s\", WiFi.SSID(i).c_str());
    }
  }
  return buf;
}

// connect        : DISCONNECTED->(NO_SSID_AVAIL)->IDLE->CONNECTED
// disconnect     : DISCONNECTED->(NO_SSID_AVAIL)->IDLE->CONNECTED->DISCONNECTED
// no SSID        : DISCONNECTED->NO_SSID_AVAIL (timeout)
// password error : DISCONNECTED (timeout)
uint32_t last_udp;
int readWifi(void)
{
  if(WiFi.status() != WL_CONNECTED) {
    switch(connection_status) {
    case CONNECTION_TCP:
    case CONNECTION_WIFI:
      WiFi.disconnect();
      connection_status = CONNECTION_NONE;
      break;
    case CONNECTION_CONNECTING:
      if(millis() - connection_start > 8000) {
        WiFi.disconnect();
        connection_status = CONNECTION_NONE;
      }
      break;
    }
    return -1;
  }

  uint32_t cur = millis();
  if(cur - last_udp > 2000) {
    last_udp = cur;
//  udp.broadcastTo(mVersion, PORT);
    uint32_t adrs = WiFi.localIP();
    uint32_t subnet = WiFi.subnetMask();
    udp.writeTo((uint8_t*)mVersion, sizeof(mVersion)-1, IPAddress(adrs|~subnet), PORT);
  }

  switch(connection_status) {
  case CONNECTION_NONE:
  case CONNECTION_CONNECTING:
    server.begin();
#if defined(_M5STACK_H_) || defined(_M5STICKC_H_)
    M5.Lcd.fillScreen(BLACK);
    M5.Lcd.setCursor(0,0);
    M5.Lcd.println(WiFi.localIP());
#endif
    DPRINT(WiFi.localIP());
    connection_status = CONNECTION_WIFI;

  case CONNECTION_WIFI:
    client = server.available();
    if(!client) {
      return -1;
    }
    DPRINT(\"connected\");
    connection_status = CONNECTION_TCP;

  case CONNECTION_TCP:
    if(!client.connected()) {
      DPRINT(\"disconnected\");
      client.stop();
      connection_status = CONNECTION_WIFI;
      return -1;
    }
    if(client.available()<=0) {
      return -1;
    }
    return client.read();
  }
}
",
	// PCモード/書き込みモード setup処理 (C言語)
	"setup":"
preferences.begin(\"tukurutch\", false);

// robot_normal.ino
Serial.begin(115200);

#ifdef useLED
  ledStrip.Begin();
#endif

// reset all Servo to initial Position
servoInit();
setServo(0, servoL);
setServo(1, servoR);

// reset all Motor to initial Setting
Motor_INIT();
delay(50);
setMotorSpeed(MotorL, 0);
setMotorSpeed(MotorR, 0);

// init ADC
ADC_INIT();

// init DIO
DIO_INIT();


preferences.getString(\"ssid\", g_ssid, sizeof(g_ssid));
preferences.getString(\"password\", g_pass, sizeof(g_pass));
Serial.print(\"Connecting to \");    Serial.println(g_ssid);

//WiFi.mode(WIFI_STA);
if(g_ssid[0]) {
  WiFi.begin(g_ssid, g_pass);
  connection_status = CONNECTION_CONNECTING;
  connection_start = millis();
  #ifndef PCMODE
    waitWifi();
  #endif
}
",
	// PCモード/書き込みモード loop処理 (C言語)
	"loop":"
remote.updateRemote();
",

	// PCモード/書き込みモード スクラッチブロック定義
	"blockSpecs": [
	// type			: w-実行関数, R-取得関数, B-true/false取得, h-プログラム開始
	// Block定義	: パラメータ %n-数値, %d-数値+enum, %s-文字列, %m-文字列+enum
	// remote		: 通常関数, 引数+戻値 型定義 B-int8, S-int16, L-int32, F-float, D-double, s-string, b-byteArray
	// custom		: 特殊関数, robot.js呼び出し(ext.Block名). PCモードと書き込みモードで処理を分けるとき使用。
	// enum			: enum値取得
	// 実行/取得関数: 引数 {0},{1}, 関数の区切り＝wブロック';', R/Bブロック','  (C言語)

	//  type | Block定義                               | Block名           | 初期値     |remote/custom/enum    | 実行/取得関数
	//-------+-----------------------------------------+-------------------+------------+----------------------+----------------------------------
		["h", "Program Start",							"runArduino",					{}],	// 変更禁止

		["-"],	// ブロック区切り

		["w", "%d.direction at speed %d.speedvalue",	"setRobot",  "run forward",255,	{"remote":["B","B"],	"func":"setRobot({0},{1});"}],
		["w", "stop",									"stopRobot",					{"remote":[],			"func":"setRobot(0,0);"}],
		["w", "set motor%d.servoch speed %d.motorvalue","setMotor",			"ch-L",255,	{"remote":["B","S"],	"func":"setMotorSpeed({0},{1});"}],

		["R", "%d.direction .",							"enumDirection",  "run forward",{"enum":"",				"func":"{0}"}],

		["-"],

		["w", "NeoPixel %d.neopixel",					"setNeoPixel",		"white",	{"remote":["B"],		"func":"SetNeoPixel({0});"}],
		["w", "NeoPixel red %n, green %n, blue %n",		"setNeoPixelRGB",	32,32,32,	{"remote":["B","B","B"],"func":"SetNeoPixelRGB({0},{1},{2});"}],
		["w", "set servo %m.servoch %n",				"setServo",			"ch-L",90,	{"remote":["B","B"],	"func":"setServo({0},{1});"}],
		["B", "read digital pin %d.din",				"getDigital",		0,			{"remote":["B",		"B"],"func":"getDigital({0})"}],
		["R", "read analog pin %d.analog",				"getAnalog",		0,			{"remote":["B",		"S"],"func":"getAdc({0})"}],

		["-"],

		// robot.js呼び出し
		["B", "[RCWCont..] remote pressed",				"checkRemoteKey",				{"custom":"", 			"func":"remote.checkRemoteKey()"}],
		["B", "[RCWCont..] ir remote %d.ircode pressed","isRemoteKey",		"UP",		{"custom":"",			"func":"remote.isRemoteKey({0})"}],
		["R", "[RCWCont..] get remote X",				"getRemoteX",					{"custom":"",			"func":"remote.x"}],
		["R", "[RCWCont..] get remote Y",				"getRemoteY",					{"custom":"",			"func":"remote.y"}],

		["-"],

		// WiFi設定
		["R", "status WIFI",							"statusWifi",					{"remote":[			"s"],"func":"statusWifi()"}],
		["R", "scan WIFI",								"scanWifi",						{"remote":[			"s"],"func":"scanWifi()"}],
		["R", "connect WIFI %s %s",						"connectWifi","ssid","pass",	{"remote":["s","s",	"B"],"func":"connectWifi({0},{1})"}],
	],
	"menus": {
		"neopixel":["off","red","green","blue","white"],
		"motordir":["stop","forward","back"],
		"direction":["stop","run forward","turn left","turn right","run backward","rotate left","rotate right"],
		"din":[0,1,2,3],
		"analog":[0,1],
		"servoch":["ch-L","ch-R"],
		"motorvalue":[255,100,50,0,-50,-100,-255],
		"speedvalue":[255,100,50,0],
		"ircode":["UP","DOWN","RIGHT","LEFT","Y","A","B","X","L1","L2","R1","R2","START","SELECT",],

		"digital":["HIGH","LOW"],
		"onoff":["On","Off"],
	},
	"values":{
		"off":0,"red":1,"green":2,"blue":3,"white":4,
		"stop":0,"forward":1,"back":2,
		"run forward":1,"turn left":2,"turn right":3,"run backward":4,"rotate left":5,"rotate right":6,
		"ch-L":0,"ch-R":1,
		"UP":1,"DOWN":2,"RIGHT":3,"LEFT":4,"Y":5,"A":6,"B":7,"X":8,"L1":9,"L2":10,"R1":11,"R2":12,"START":13,"SELECT":14,

		"HIGH":1,"LOW":0,
		"On":1,"Off":0,
	},
	"translators":{
		"ja":{
			"run forward":"前", "turn left":"左", "turn right":"右", "run backward":"後", "rotate left":"左旋回", "rotate right":"右旋回",
			"%d.direction at speed %d.speedvalue"			:"%d.direction 向きに %d.speedvalue の速さで動かす",
			"set motor%d.servoch speed %d.motorvalue"		:"モーター %d.servoch の速さを %d.motorvalue にする",
			"set motor%d.servoch direction%d.motordir"		:"モーター %d.servoch を %d.motordir へ動かす",
			"set servo %m.servoch %n"						:"サーボ %d.servoch の角度を %n にする",
			"read digital pin %d.din"						:"デジタルピン %d.din",
			"read analog pin %d.analog"						:"アナログピン %d.analog",

			"[RCWCont..] remote pressed"					:"[RCWCont..] リモコンボタンが押された",
			"[RCWCont..] ir remote %d.ircode pressed"		:"[RCWCont..] 押されたのが %d.ircode のボタン",
			"[RCWCont..] get remote X"						:"[RCWCont..] アナログXの値",
			"[RCWCont..] get remote Y"						:"[RCWCont..] アナログYの値",
		}
	}
}
