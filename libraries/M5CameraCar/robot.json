{
	"name"			: "M5CameraCar",
	"port"			: 0,										// 変更禁止
	"boardType"		: "esp32:esp32:esp32",						// package:platform:board

	"sort"			: 11,										// メニュー上の表示順序
	"extensionAuthor": "sohtamei",								// この拡張スクリプトの作者
	"helpURL"		: "http://sohta02.web.fc2.com/familyday_orgel.html",
	"productInfoURL": "http://sohta02.web.fc2.com/familyday_orgel.html",
	"sampleDir"		: "sample/M5Series",						// サンプルディレクトリ
	"javascriptURL"	: "robot.js",
	"normalFW"		: "",										// 最初のプログラム,  .ino, .cpp.standard.hex
	"pcmodeFW"		: "robot_pcmode/robot_pcmode",				// PC modeプログラム, .ino, .cpp.standard.hex, .ino.template
	"libraryPath"	: "M5CameraCarLib",							// 専用ライブラリ(option)
	"prefs"			: ["custom_CPUFreq=esp32_240",
						"custom_DebugLevel=esp32_none",
						"custom_FlashFreq=esp32_80",
						"custom_FlashMode=esp32_qio",
						"custom_FlashSize=esp32_4M",
						"custom_PSRAM=esp32_enabled",
						"custom_PartitionScheme=esp32_default",
						"custom_UploadSpeed=esp32_921600"],

	// C言語記述注意 : " を使うときは \" とすること

	// PCモード/書き込みモード ヘッダ (C言語)
	"header":"
#define mVersion \"M5CameraCar\"

#include <HTTPClient.h>
#include <libb64/cencode.h>
#include <libb64/cdecode.h>
#include <Preferences.h>
#include \"TukurutchEsp.h\"
#include \"M5CameraCar.h\"


WebsocketsServer wsServer;
static Preferences preferencesRobot;

#define numof(a) (sizeof(a)/sizeof((a)[0]))

#define P_LED		14
#define P_SRV0		13
#define P_SRV1		4

enum {
  CAL0P = 0,
  CAL0M,
  CAL1P,
  CAL1M,
};

enum {
  PWM0,
  PWM25,
  PWM50,
  PWM75,
  PWM100,
};

struct calibrate {
  uint16_t id;
  uint16_t ver;
  uint16_t T;
  uint16_t _reserve;
  uint16_t pwm[4][4];		// CAL0P,CAL0M,CAL1P,CAL1M  PWM0,PWM25,PWM50,PWM75
   int16_t maxOffset[2];
   int16_t speedMax[4];		// CAL0P,CAL0M,CAL1P,CAL1M
} static cal;
static uint16_t pwm0[2];

static const struct calibrate calInit = {
  0,
  1,
  18,
  0,
  {{308,314,319,336},{297,292,287,270},{295,290,285,267},{309,315,320,339}},
  {0,0},
  {2000,-2000,2000,-2000},
};

enum {
  SERVO_IDLE,
  SERVO_STOP_REQ,
  SERVO_OFF_REQ,
  SERVO_REV_REQ,
};
static uint8_t servo_stt = 0;
static uint32_t servo_time = 0;

void _setLED(uint8_t onoff)
{
  digitalWrite(P_LED, !onoff);
  pinMode(P_LED, OUTPUT);
}

uint8_t _getSw(uint8_t idx)
{
  int ret;
  pinMode(4, INPUT_PULLDOWN);
  digitalWrite(13, 1);
  pinMode(13, OUTPUT);
  delay(5);
  ret = digitalRead(4);
  pinMode(13, INPUT);
  return ret;
}

static uint16_t pwm_last[2];
static uint16_t pwm_req[2];
static uint16_t pwm_duration = 0;

#define PWM_MIN     143
#define PWM_NEUTRAL 307
#define PWM_MAX     471
const struct {uint8_t ledc; uint8_t port;} servoTable[] = {{8,P_SRV0},{9,P_SRV1}};
void _setPwm(uint8_t idx, int16_t data)
{
  ledcAttachPin(servoTable[idx].port, servoTable[idx].ledc);
  ledcWrite(servoTable[idx].ledc, data);
  pwm_last[idx] = data;
}

static const uint16_t maxOffsetTbl[] = {164,83,70,63,58,54,51,48,45,43,41,40,38,37,35,34,33,32,31,30,29,28,27,26,26,25,24,24,23,22,22,21,21,20,19,19,18,18,17,17,16,16,16,15,15,14,14,14,13,13,12};

int16_t limitOffset(int16_t offset)
{
       if(offset >= (int) numof(maxOffsetTbl)) offset =   numof(maxOffsetTbl)-1;
  else if(offset <= (int)-numof(maxOffsetTbl)) offset = -(numof(maxOffsetTbl)-1);
  return offset;
}

void _setMotor(int16_t left, int16_t right/* -4 ~ +4 */,
  int16_t calib,   /* -50(Left) ~ +50(right) */
  int16_t duration)
{
       if(left >  PWM100) left =  PWM100;
  else if(left < -PWM100) left = -PWM100;

       if(right >  PWM100) right =  PWM100;
  else if(right < -PWM100) right = -PWM100;

  uint16_t pwmL = 0;
  uint16_t pwmR = 0;
  int data = 0;
  int calib4 = (calib + ((calib>=0)?2:-2) )/4;
  switch(left) {
  case PWM100:
    data = limitOffset(cal.maxOffset[0] - calib*2);
    if(data >= 0)
      pwmL = cal.pwm[CAL0P][PWM0] + maxOffsetTbl[data];
    else
      pwmL = PWM_MAX;
    break;

  case -PWM100:
    data = limitOffset(cal.maxOffset[1] - calib*2);
    if(data >= 0)
      pwmL = cal.pwm[CAL0M][PWM0] - maxOffsetTbl[data];
    else
      pwmL = PWM_MIN;
    break;

  case PWM0:
    if(calib == 0)
      pwmL = 0;
    else if(calib > 0)
      pwmL = cal.pwm[CAL0P][PWM0] + calib4;
    else
      pwmL = cal.pwm[CAL0M][PWM0] + calib4;
    break;

  default:
    if(left >= 0)
      pwmL = cal.pwm[CAL0P][ left] + calib4;
    else
      pwmL = cal.pwm[CAL0M][-left] + calib4;
    break;
  }

  switch(right) {
  case PWM100:
    data = limitOffset(cal.maxOffset[0] - calib*2);
    if(data >= 0)
      pwmR = PWM_MIN;
    else
      pwmR = cal.pwm[CAL1P][PWM0] - maxOffsetTbl[-data];
    break;

  case -PWM100:
    data = limitOffset(cal.maxOffset[1] - calib*2);
    if(data >= 0)
      pwmR = PWM_MAX;
    else
      pwmR = cal.pwm[CAL1M][PWM0] + maxOffsetTbl[-data];
    break;

  case PWM0:
    if(calib == 0)
      pwmR = 0;
    else if(calib > 0)
      pwmR = cal.pwm[CAL1M][PWM0] + calib4;
    else
      pwmR = cal.pwm[CAL1P][PWM0] + calib4;
    break;

  default:
    if(right >= 0)
      pwmR = cal.pwm[CAL1P][ right] + calib4;
    else
      pwmR = cal.pwm[CAL1M][-right] + calib4;
    break;
  }
//Serial.printf(\"%d %d\\n\", pwmL, pwmR);

  servo_stt = SERVO_IDLE;
  if(pwm_last[0] && pwmL && ((pwm_last[0]>=pwm0[0]) != (pwmL>=pwm0[0]))) {
    _setPwm(0, 0);
    servo_stt = SERVO_REV_REQ;
  } else {
    _setPwm(0, pwmL);
  }

  if(pwm_last[1] && pwmR && ((pwm_last[1]>=pwm0[1]) != (pwmR>=pwm0[1]))) {
    _setPwm(1, 0);
    servo_stt = SERVO_REV_REQ;
  } else {
    _setPwm(1, pwmR);
  }

  if(servo_stt == SERVO_REV_REQ) {
    servo_time = millis() + 40;
    pwm_req[0] = pwmL;
    pwm_req[1] = pwmR;
    pwm_duration = duration;

  } else if(duration) {
    servo_stt = SERVO_STOP_REQ;
    servo_time = millis() + duration;
  } else {
    servo_stt = SERVO_IDLE;
    servo_time = 0;
  }
}

void _stopServo(void)
{
  servo_stt = SERVO_IDLE;
  servo_time = 0;
  _setPwm(0, 0);
  _setPwm(1, 0);
}

enum {
  CMD_STOP = 0,
  CMD_FORWARD,
  CMD_LEFT,
  CMD_RIGHT,
  CMD_BACK,
  CMD_ROLL_LEFT,
  CMD_ROLL_RIGHT,
  CMD_CALIBRATION,
};

struct { int16_t L; int16_t R;} static const dir_table[7] = {
//  L   R
  { 0,  0},  // 0:STOP
  { 1,  1},  // 1:FORWARD
  { 0,  1},  // 2:LEFT
  { 1,  0},  // 3:RIGHT
  {-1, -1},  // 4:BACK
  {-1,  1},  // 5:ROLL_LEFT
  { 1, -1},  // 6:ROLL_RIGHT
             // 7:CALIBRATION
};

void _setCar(uint8_t direction, uint16_t speed, int16_t calib, int16_t duration)
{
  if(direction >= CMD_CALIBRATION) {
    _setPwm(0, PWM_NEUTRAL);
    _setPwm(1, PWM_NEUTRAL);
  } else {
    _setMotor(speed*dir_table[direction].L, speed*dir_table[direction].R, calib, duration);
  }
}

/////////////////////////////////////////////

static char* _downloadCal(int16_t id, char* base64)
{
  if(base64 && base64[0]) {
    int len = base64_decode_chars(base64, strlen(base64), strBuf);
    if(len == sizeof(cal)) {
      memcpy((char*)&cal, strBuf, len);
      preferencesRobot.putBytes(\"calib\", &cal, sizeof(cal));
      pwm0[0] = (cal.pwm[CAL0P][PWM0] + cal.pwm[CAL0M][PWM0])/2;
      pwm0[1] = (cal.pwm[CAL1P][PWM0] + cal.pwm[CAL1M][PWM0])/2;
      snprintf(strBuf, sizeof(strBuf), \"OK\");
    } else {
      snprintf(strBuf, sizeof(strBuf), \"Error\");
    }
    return strBuf;
  }

  char url[50];
  if(id==0) id=cal.id;
  snprintf(url, sizeof(url), \"http://sohta02.web.fc2.com/calib/M5CC%04d.txt\", id);
  memset(strBuf, 0, sizeof(strBuf));
  HTTPClient http;
  http.begin(url);
  int httpCode = http.GET();
  if(httpCode == HTTP_CODE_OK) {
    String payload = http.getString();
    Serial.println(payload);
    if(base64_decode_expected_len(payload.length()) >= sizeof(strBuf)) goto Error;

    int len = base64_decode_chars((const char*)payload.c_str(), payload.length(), strBuf);
    if(len != sizeof(cal)) goto Error;
    memcpy((char*)&cal, strBuf, len);
    preferencesRobot.putBytes(\"calib\", &cal, sizeof(cal));
    pwm0[0] = (cal.pwm[CAL0P][PWM0] + cal.pwm[CAL0M][PWM0])/2;
    pwm0[1] = (cal.pwm[CAL1P][PWM0] + cal.pwm[CAL1M][PWM0])/2;

    uint16_t i;
    for(i=0; i<len; i++) Serial.printf(\"%02x\", ((uint8_t*)&cal)[i]);
    Serial.println();
    snprintf(strBuf, sizeof(strBuf), \"OK:%s\", payload.c_str());
  } else {
    Serial.printf(\"[HTTP] GET... failed, error: %s\\n\", http.errorToString(httpCode).c_str());
Error:
    snprintf(strBuf, sizeof(strBuf), \"Error\");
  }
  http.end();
  return strBuf;
}

char* _getCal(void)
{
  base64_encode_chars((char*)&cal, sizeof(cal), strBuf);
  return strBuf;
}

void _setServo(uint8_t idx, int16_t data/*0~180*/)
{
  if(idx >= numof(servoTable)) return;

  #define srvMin 103		// 0.5ms/20ms*4096 = 102.4 (-90c)
  #define srvMax 491		// 2.4ms/20ms*4096 = 491.5 (+90c)
  if(data < 0) data = 0;
  else if(data > 180) data = 180;

  uint16_t pwmWidth = (data * (srvMax - srvMin)) / 180 + srvMin;
  _setPwm(idx, pwmWidth);
}

void onConnect(String ip)
{
  _setLED(1);

  wsServer.listen(PORT_WEBSOCKET);
  startCameraServer();
  Serial.println(ip);
}
",
	// PCモード/書き込みモード setup処理 (C言語)
	"setup":"
_setLED(0);

Serial.begin(115200);

M5CameraCar_init();

if(_getSw(0)) {
  _setLED(1);
  delay(100);
  _setLED(0);
  Serial.println(\"Waiting for SmartConfig.\");
  WiFi.mode(WIFI_STA);
  WiFi.beginSmartConfig();
  while (!WiFi.smartConfigDone()) {
    delay(1000);
    _setLED(1);
    delay(100);
    _setLED(0);
  }
  Serial.println(\"SmartConfig received.\");
}

// ServoCar
ledcSetup(servoTable[0].ledc, 50/*Hz*/, 12/*bit*/);
ledcSetup(servoTable[1].ledc, 50/*Hz*/, 12/*bit*/);

#ifndef PCMODE
initWifi(mVersion, true, onConnect);
#else
initWifi(mVersion, false, onConnect);
#endif

preferencesRobot.begin(\"M5CameraCar\", false);
if(preferencesRobot.getBytes(\"calib\", &cal, sizeof(cal)) < sizeof(cal)) {
  Serial.println(\"init calib\");
  memset(&cal, 0, sizeof(cal));
  preferencesRobot.putBytes(\"calib\", &cal, sizeof(cal));
}
pwm0[0] = (cal.pwm[CAL0P][PWM0] + cal.pwm[CAL0M][PWM0])/2;
pwm0[1] = (cal.pwm[CAL1P][PWM0] + cal.pwm[CAL1M][PWM0])/2;
",
	// PCモード/書き込みモード loop処理 (C言語)
	"loop":"
  loopWebSocket();
#ifndef PCMODE
  sendNotifyArduinoMode();
#endif
  if(servo_stt) {
    int32_t d = servo_time - millis();
    if(d <= 0) {
      switch(servo_stt) {
      case SERVO_REV_REQ:
        if(pwm_duration) {
          servo_stt = SERVO_STOP_REQ;
          servo_time = millis() + pwm_duration;
        } else {
          servo_stt = SERVO_IDLE;
          servo_time = 0;
        }
        _setPwm(0, pwm_req[0]);
        _setPwm(1, pwm_req[1]);
        break;

      case SERVO_STOP_REQ:
      case SERVO_OFF_REQ:
      default:
        servo_stt = SERVO_IDLE;
        servo_time = 0;
        _setPwm(0, 0);
        _setPwm(1, 0);
        break;
      }
    }
  }
",

	// PCモード/書き込みモード スクラッチブロック定義
	"blockSpecs": [
	// type			: w-実行関数, R-取得関数, B-true/false取得, h-プログラム開始
	// Block定義	: パラメータ %n-数値, %d-数値+enum, %s-文字列, %m-文字列+enum
	// remote		: 通常関数, 引数+戻値 型定義 B-int8, S-int16, L-int32, F-float, D-double, s-string, b-byteArray
	// custom		: 特殊関数, robot.js呼び出し(ext.Block名). PCモードと書き込みモードで処理を分けるとき使用。
	// enum			: enum値取得
	// 実行/取得関数: 引数 {0},{1}, 関数の区切り＝wブロック';', R/Bブロック','  (C言語)

	//  type | Block定義                               | Block名           | 初期値     |remote/custom/enum    | 実行/取得関数
	//-------+-----------------------------------------+-------------------+------------+----------------------+----------------------------------
		["h", "Program Start",							"runArduino",					{}],	// 変更禁止

		["w", "%d.direction at speed %d.speed calib %n duration %n",
														"setCar", "run forward",4,0,0,	{"remote":["B","S","S","S"],"func":"_setCar({0},{1},{2},{3});"}],
		["w", "set motor left %d.speed right %d.speed calib %n duration %n",
														"setMotor",			4,4,0,0,	{"remote":["S","S","S","S"],"func":"_setMotor({0},{1},{2},{3});"}],
	//	["w", "set servo %d.servoch %d.angle",			"setServo",			0,90,		{"remote":["B","B"],		"func":"_setServo({0},{1});"}],
	//	["w", "set motor %d.servoch pwm %d.pwm",		"setPwm",			0,0,		{"remote":["B","S"],		"func":"_setPwm({0},{1});"}],
		["w", "set servo %d.servoch %n",				"setServo",			0,90,		{"remote":["B","B"],		"func":"_setServo({0},{1});"}],
		["w", "set motor %d.servoch pwm %n",			"setPwm",			0,307,		{"remote":["B","S"],		"func":"_setPwm({0},{1});"}],
		["w", "stop",									"stopCar",						{"remote":[],				"func":"_stopServo();"}],

		["R", "%d.direction .",							"enumDirection",  "run forward",{"enum":"",				"func":"{0}"}],

		["w", "set LED %d.onoff",						"setLED",			"On",		{"remote":["B"],		"func":"_setLED({0});"}],

// for FW
		["R", "download calibration %n %s",				"downloadCal",		1,"",		{"remote":["S","s",	"s"],	"func":"_downloadCal({0},{1})"}],
// for scratch3
//		["R", "download calibration %n %n",				"downloadCal",		1,0,		{"remote":["S","S",	"s"],	"func":"_downloadCal({0},{1})"}],
		["R", "get cal",								"getCal",						{"remote":[			"s"],	"func":"_getCal()"}],

		["-"],

		// WiFi設定
		["R", "status WIFI",							"statusWifi",					{"remote":[			"s"],"func":"statusWifi()"}],
		["R", "scan WIFI",								"scanWifi",						{"remote":[			"s"],"func":"scanWifi()"}],
		["R", "connect WIFI %s %s",						"connectWifi","ssid","pass",	{"remote":["s","s",	"B"],"func":"connectWifi({0},{1})"}],
	],
	"menus": {
		"onoff"		:["On","Off"],
		"direction"	:["stop","run forward","turn left","turn right","run backward","rotate left","rotate right","calibration"],
		"servoch"	:[0,1],
		"speed"		:[4,2,1,0,-1,-2,-4],
	//	"angle"		:[0,90,180],
	//	"pwm"		:[471,307,143,0],
	//	"calib"		:[50,25,0,-25,-50],
	// scratch3.0でmenu表示と数値入力が両立しない
	},
	"values":{
		"On":1,"Off":0,
		"stop":0,"run forward":1,"turn left":2,"turn right":3,"run backward":4,"rotate left":5,"rotate right":6,"calibration":7,
	},
	"translators":{
		"ja":{
			"stop":"ストップ", "run forward":"前", "turn left":"左", "turn right":"右", "run backward":"後", "rotate left":"左旋回", "rotate right":"右旋回", "calibration":"原点調整",
			"%d.direction at speed %d.speed calib %n duration %n"			:"%d.direction 向きに %d.speed の速さで動かす(補正 %n , %n ms)",
			"set motor left %d.speed right %d.speed calib %n duration %n"	:"左 %d.speed 右 %d.speed で動かす(補正 %n , %n ms)",
			"set servo %d.servoch %n"											:"サーボ %d.servoch の角度を %n にする",
			"set motor %d.servoch pwm %n"										:"サーボ %d.servoch にPWM %n を設定",

			"download calibration %n %s"					:"補正データダウンロード ID=%n データ%s",
			"download calibration %n %n"					:"補正データダウンロード ID=%n データ%n",
			"get cal"										:"補正データ表示",

			"set LED %d.onoff"								:"LED %d.onoff",
			"SW %d.sw"										:"スイッチ %d.sw",
		}
	}
}
